---
import Layout from "@layouts/Layout.astro"; // Layout component
import categories from "@json/categories.json"; // JSON file containing categories data
import ShowCoins from "@components/Shared/ShowCoins.astro";
import { getTitleBasedOnDifficulty } from "@utils/getTitleBasedOnDifficulty";
import GameHeadline from "@components/Game/GameHeadline.astro";
import FeedbackOverlay from "@components/Overlays/FeedbackOverlay.astro";
import EndOverlay from "@components/Overlays/EndOverlay.astro";
import GoldenLPOverlay from "@components/Overlays/GoldenLPOverlay.astro";
import LoadingSpinner from "@components/Game/LoadingSpinner.astro";
import Joker from "@components/Game/Joker.astro";
import ErrorMessage from "@components/Shared/ErrorMessage.astro";

/**
 * Get the user object from the Astro context
 */
const user = Astro.locals.user;

/**
 * If the user is not logged in, redirect them to the login page.
 */
if (!user) {
  /**
   * Redirect the user to the login page.
   */
  return Astro.redirect("/");
}

/**
 * Destructure `category` and `round` from `Astro.params`
 */
const { category, difficulty } = Astro.params;

const currentCategoryData = categories.find((cat) => cat.slug === category);

const playerTitle = getTitleBasedOnDifficulty(difficulty || "easy");
---

<Layout title={`${currentCategoryData?.headline}`} showHeaderIcons={false}>
  <div slot="left-headercol">
    <ShowCoins />
  </div>

  <FeedbackOverlay />

  <EndOverlay />

  <GoldenLPOverlay
    playerTitle={playerTitle}
    category={currentCategoryData?.headline || ""}
  />

  <GameHeadline headline={currentCategoryData?.headline} />

  <LoadingSpinner />

  <div
    id="question-container"
    role="main"
    aria-label="Spielbereich"
    data-categoryName={currentCategoryData?.headline}
    data-genre={category}
    data-userID={user.id}
    date-difficulty={difficulty}
  >
    <div id="question" role="heading" aria-level="2"></div>
    <div id="options" role="radiogroup" aria-label="Antwortmöglichkeiten"></div>
  </div>

  <Joker />
</Layout>

<style is:global lang="scss">
  #question-container {
    max-width: 768px;
    margin: 0 auto;
    padding: var(--padding-medium);

    text-align: center;

    opacity: 1;
    background-color: var(--secondary-color);
    border-radius: var(--border-radius);
    box-shadow: var(--box-shadow);

    transition: opacity 0.5s ease;
  }

  #question-container.hidden {
    opacity: 0;
  }

  #question {
    margin-bottom: var(--padding-large);
    font-size: 1.25rem;
    font-weight: 600;
  }

  #options {
    display: flex;
    flex-direction: column;
    gap: var(--padding-medium);
  }

  .overlay.hidden {
    display: none;
  }

  .popup.hidden {
    display: none;
  }

  .centerButton {
    display: flex;
    justify-content: center;
    margin-top: var(--padding-large);
  }

  .centerButton .button {
    cursor: pointer;

    padding: var(--padding-small) var(--padding-medium);

    font-size: var(--button-font-size);

    background-color: var(--highlight-color);
    border: none;
    border-radius: var(--border-radius);
    box-shadow: var(--box-shadow);

    transition:
      background-color 0.3s ease,
      transform 0.2s ease;
  }

  .centerButton .button:hover {
    transform: scale(1.05);
    background-color: var(--button-hover-color);
  }

  .achievement-notification {
    position: fixed;
    top: var(--padding-medium);
    right: var(--padding-medium);
    z-index: var(--layer-above);

    display: flex;
    align-items: center;
    gap: var(--padding-medium);

    padding: var(--padding-medium);
    background-color: var(--secondary-color);
    border-radius: var(--border-radius);
    box-shadow: var(--box-shadow);

    animation: slideIn 0.5s ease-out;

    .achievement-icon {
      font-size: 2rem;
    }

    .achievement-info {
      h3 {
        color: var(--highlight-color);
        font-size: var(--body-font-size);
        font-weight: 600;
        margin-bottom: var(--padding-small);
      }

      p {
        font-size: calc(var(--body-font-size) * 0.9);
        margin-bottom: calc(var(--padding-small) / 2);

        &:last-child {
          color: var(--highlight-color);
          font-weight: 600;
        }
      }
    }
  }

  @keyframes slideIn {
    from {
      transform: translateX(100%);
      opacity: 0;
    }
    to {
      transform: translateX(0);
      opacity: 1;
    }
  }

  @media (prefers-reduced-motion: reduce) {
    .achievement-notification {
      animation: none;
    }
  }
</style>

<script>
  import { stopAudio } from "@utils/audio/audioControls";
  import { ErrorHandler } from "@utils/error/errorHandler";
  import {
    handleEndGame,
    restartGame,
    showEndgamePopup,
    showGoldenLpPopup,
  } from "@utils/game/endGameUtils";
  import { getRandomQuestion } from "@utils/game/getRandomQuestion";
  import { getUserAndCategoryPoints } from "@utils/game/getUserAndCategoryPoints";
  import {
    createInitialJokerState,
    use5050Joker,
  } from "@utils/game/jokerUtils";
  import { initializeMediaElements, updateMedia } from "@utils/game/mediaUtils";
  import { QueueManager } from "@utils/queue/queueManager";
  import { shuffleArray } from "@utils/share/shuffleArray";
  import { AchievementSystem } from "@utils/achievements/achievementSystem";
  import type { PlayerStats } from "../../types/achievements";

  document.addEventListener("DOMContentLoaded", async function () {
    QueueManager.startProcessing();
    const achievementSystem = new AchievementSystem();
    interface CategoryWins {
      [key: string]: number;
    }

    const scoreElement = document.querySelector(
      ".coinsCount",
    ) as HTMLParagraphElement;
    const roundElement = document.querySelector(
      ".round",
    ) as HTMLParagraphElement;
    const feedbackElement = document.getElementById(
      "feedback",
    ) as HTMLParagraphElement;
    const questionElement = document.getElementById(
      "question",
    ) as HTMLParagraphElement;
    const optionsContainer = document.getElementById(
      "options",
    ) as HTMLDivElement;
    const questionContainer = document.getElementById(
      "question-container",
    ) as HTMLDivElement;
    const overlayCover = document.getElementById(
      "overlay-cover",
    ) as HTMLImageElement;
    const audioPreview = document.getElementById(
      "audio-preview",
    ) as HTMLAudioElement;
    const audioPreviewSource = document.getElementById(
      "audio-preview-source",
    ) as HTMLSourceElement;
    const spotifyLink = document.getElementById(
      "spotify-link",
    ) as HTMLAnchorElement;
    const deezerLink = document.getElementById(
      "deezer-link",
    ) as HTMLAnchorElement;
    const appleLink = document.getElementById(
      "apple-link",
    ) as HTMLAnchorElement;

    // Tracking für schnelle Antworten
    let fastAnswersThisGame = 0;
    let currentStats: PlayerStats = {
      // Basis-Statistiken
      userId: "",
      totalGames: 0,
      totalPoints: 0,
      totalCorrectAnswers: 0,
      totalJokersUsed: 0,
      gamesWithoutJoker: 0,
      maxStreak: 0,
      fastAnswers: 0,
      perfectGames: 0,

      // Zeit-basierte Stats
      maxCorrectAnswersPerGame: 0,
      firstGameCorrectAnswers: 0,
      perfectWinStreak: 0,
      fastAnswersTotal: 0,
      ultraFastAnswers: 0,
      earlyGames: 0,
      eveningGames: 0,
      eveningWins: 0, // Hinzugefügt
      weekendGames: 0,
      consecutiveDays: 0,
      daysPlayedInWeek: 0,
      perfectMonthStreak: 0,
      lastPlayedAt: new Date(),
      lastUpdated: new Date(),
      firstPlayedAt: new Date(),

      // Schwierigkeitsgrade
      easyDifficultyWins: 0,
      mediumDifficultyWins: 0,
      hardDifficultyWins: 0,

      // Kategorie-basierte Stats
      categoryStats: {},
      categoryWins: {},
      uniqueGenresPlayed: 0,
      genreFirstPlaces: 0,

      // Social Stats
      totalShares: 0,
      followers: 0,
      friends: 0,
      comments: 0,
      likedSongs: 0,
      playlists: 0,
      popularPlaylists: 0,
      communityWins: 0,

      // Ranglisten & Achievements
      globalRank: 0,
      monthsInTop10: 0,
      unlockedAchievements: 0,
      simultaneousRecords: 0,

      // Spiel-Performance
      bigComebacks: 0,
      maxWinsPerDay: 0,
      fastestWin: 0,
      comebacks: 0,

      // Saisonale Stats
      summerGames: 0,
      winterGames: 0,
      holidayGames: 0,

      // System-Konstanten
      totalRecords: 0,
      totalAchievements: 0,
      totalGenres: 0,

      // Erweiterte Stats
      maxConsecutiveDays: 0,
      perfectRounds: 0,

      // Komplexe Statistiken
      roundStats: {
        total: 0,
        perfect: 0,
        consecutive: 0,
        maxConsecutive: 0,
      },
      timeOfDayStats: {
        morning: 0,
        afternoon: 0,
        evening: 0,
        night: 0,
        morningWins: 0,
        afternoonWins: 0,
        eveningWins: 0,
        nightWins: 0,
      },
      streaks: {
        current: 0,
        max: 0,
        dailyCurrent: 0,
        dailyMax: 0,
        perfectCurrent: 0,
        perfectMax: 0,
      },
    };

    // Hole initiale Statistiken
    async function loadPlayerStats(userId: string) {
      try {
        const response = await fetch(`/api/achievements/${userId}`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            userId,
          }),
        });

        if (response.ok) {
          currentStats = await response.json();
        }
      } catch (error) {
        console.error("Fehler beim Laden der Statistiken:", error);
      }
    }

    // Funktion zum Aktualisieren der Statistiken
    async function updatePlayerStats(userId: string, stats: PlayerStats) {
      console.log("Player Stats:", stats);

      try {
        const response = await fetch("/api/stats/update", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            userId,
            stats,
          }),
        });

        console.log("Player Stats Updated", response);

        if (!response.ok) {
          throw new Error("Fehler beim Speichern der Statistiken");
        }
      } catch (error) {
        console.error("Fehler beim Aktualisieren der Statistiken:", error);
        // await QueueManager.addToQueue("stats", { userId, stats });
      }
    }

    // Get the category from the question container
    const category = questionContainer.getAttribute("data-genre");
    const userId = questionContainer.getAttribute("data-userID");
    const categoryName = questionContainer.getAttribute("data-categoryName");
    const difficulty = questionContainer.getAttribute("date-difficulty");

    let score = 0;
    let correctAnswers = 0;
    let roundIndex = 0;
    const totalRounds =
      difficulty === "hard" ? 20 : difficulty === "medium" ? 15 : 10;
    roundElement.textContent = `${roundIndex + 1}/${totalRounds}`;

    const albumsPromise = import(`../../json/genres/${category}.json`);
    const albums: any = (await albumsPromise).default;

    const { totalUserPoints, currentCategoryPointsValue } =
      await getUserAndCategoryPoints(userId ?? "", categoryName ?? "");

    let currentQuestion: null = null;

    const jokerButton = document.getElementById(
      "joker-button",
    ) as HTMLButtonElement;
    const jokerCounterElement = document.getElementById(
      "joker-count",
    ) as HTMLElement;

    const { maxJokers, jokerState } = createInitialJokerState(
      difficulty || "easy",
    );
    let currentJokerState = jokerState;

    jokerCounterElement.textContent = `Joker: ${maxJokers} verbleibend`;

    // Event-Handler für Joker-Button
    if (jokerButton) {
      jokerButton.addEventListener("click", function () {
        const question = getCurrentQuestion();
        if (!question) return;

        currentJokerState = use5050Joker(
          question,
          currentJokerState,
          maxJokers,
          {
            updateButton: (disabled) => {
              jokerButton.disabled = disabled;
            },
            updateCounter: (remaining) => {
              jokerCounterElement.textContent = `Joker: ${remaining} verbleibend`;
            },
          },
        );
      });
    }

    const mediaElements = initializeMediaElements();
    if (!mediaElements) {
      console.error("Media-Elemente konnten nicht initialisiert werden");
      return;
    }

    function loadQuestion(question: any, album: any) {
      questionContainer.classList.add("hidden");

      const spinner = document.getElementById(
        "loading-spinner",
      ) as HTMLDivElement;
      spinner.classList.remove("hidden");

      currentQuestion = question;

      setTimeout(() => {
        questionElement.textContent = question.question;
        optionsContainer.innerHTML = "";

        const shuffledOptions = shuffleArray([...question.options]);

        questionContainer.setAttribute("role", "main");
        questionContainer.setAttribute("aria-label", "Aktuelle Spielfrage");

        questionElement.setAttribute("role", "heading");
        questionElement.setAttribute("aria-level", "2");

        optionsContainer.setAttribute("role", "radiogroup");
        optionsContainer.setAttribute("aria-label", "Antwortmöglichkeiten");

        // Erstelle alle Buttons
        shuffledOptions.forEach(function (option: any) {
          const button = document.createElement("button");
          button.textContent = option;
          button.className = "button";
          button.setAttribute("role", "radio");
          button.setAttribute("aria-checked", "false");
          button.setAttribute("aria-label", `Antwort auswählen: ${option}`);

          button.onclick = () =>
            handleAnswer(option, question.correctAnswer, question, album);
          optionsContainer.appendChild(button);
        });

        // Keyboard Navigation
        const options =
          document.querySelectorAll<HTMLElement>("#options button");
        options.forEach((button, index) => {
          button.addEventListener("keydown", (e: KeyboardEvent) => {
            switch (e.key) {
              case "ArrowDown":
              case "ArrowRight":
                e.preventDefault();
                const nextButton = options[(index + 1) % options.length];
                nextButton.focus();
                break;
              case "ArrowUp":
              case "ArrowLeft":
                e.preventDefault();
                const prevButton =
                  options[(index - 1 + options.length) % options.length];
                prevButton.focus();
                break;
              case "Enter":
              case " ":
                e.preventDefault();
                const optionText = button.textContent || "";
                handleAnswer(
                  optionText,
                  question.correctAnswer,
                  question,
                  album,
                );
                break;
            }
          });
        });

        // Setze initialen Fokus
        if (options.length > 0) {
          options[0].focus();
        }

        spinner.classList.add("hidden");
        questionContainer.classList.remove("hidden");
      }, 500);

      currentJokerState.jokerUsed = false;
    }

    function handleAnswer(
      option: any,
      correctAnswer: any,
      currentQuestion: { trivia: string },
      album: { coverSrc: string; artist: string; album: string; year: string },
    ) {
      const startTime = Date.now();
      const endTime = Date.now();
      const timeTaken = (endTime - startTime) / 1000;
      let totalPoints = 0;
      let bonusPoints = 0;
      const answerTime = Date.now() - startTime;

      // Wenn Antwort unter 5 Sekunden
      if (answerTime < 5000) {
        fastAnswersThisGame++;
      }

      if (option === correctAnswer) {
        bonusPoints = timeTaken <= 10 ? 50 : timeTaken <= 15 ? 25 : 0;
        totalPoints = 50 + bonusPoints;
        feedbackElement.classList.add("correct");
        feedbackElement.textContent = `Richtig! 50 Punkte + ${bonusPoints} Bonuspunkte`;
      } else {
        feedbackElement.classList.add("incorrect");
        feedbackElement.textContent = `Falsch! Die richtige Antwort war: ${correctAnswer}`;
      }

      feedbackElement.classList.add("show");

      setTimeout(() => {
        feedbackElement.classList.remove("show", "correct", "incorrect");
      }, 5000);

      score += totalPoints;
      updateScoreDisplay(score);

      overlayCover.src = album.coverSrc || "";
      document.getElementById("overlay-artist")!.textContent =
        album.artist || "";
      document.getElementById("overlay-album")!.textContent = album.album || "";
      document.getElementById("overlay-funfact")!.textContent =
        currentQuestion.trivia || "";
      document.getElementById("overlay-year")!.textContent = album.year || "";

      if (mediaElements) {
        updateMedia(album, mediaElements);
      }

      const overlay = document.getElementById("overlay") as HTMLDivElement;
      overlay.classList.remove("hidden");

      const nextRoundButton = document.getElementById(
        "next-round-button",
      ) as HTMLButtonElement;

      nextRoundButton.onclick = function () {
        stopAudio(); // Stoppt die Audio-Vorschau, wenn das Overlay geschlossen wird.
        overlay.classList.add("hidden");
        if (roundIndex < totalRounds - 1) {
          roundIndex++;
          roundElement.textContent = `${roundIndex + 1}/${totalRounds}`;

          const newQuestion = getRandomQuestion(
            albums,
            difficulty || "easy",
            totalRounds,
          );
          if (newQuestion) {
            loadQuestion(newQuestion.randomQuestion, newQuestion.randomAlbum);
            feedbackElement.textContent = "";
          }
        } else {
          endGame();
        }
      };
    }

    function updateScoreDisplay(score: number) {
      scoreElement.textContent = score.toString();
      scoreElement.classList.add("bonus");
      setTimeout(() => scoreElement.classList.remove("bonus"), 500);
    }

    function showAchievementNotification(achievement: any) {
      const notification = document.createElement("div");
      notification.className = "achievement-notification";
      notification.innerHTML = `
          <div class="achievement-icon">${achievement.icon}</div>
          <div class="achievement-info">
            <h3>Achievement freigeschaltet!</h3>
            <p>${achievement.title}</p>
            <p>${achievement.description}</p>
            <p>+${achievement.points} Punkte</p>
          </div>
        `;
      document.body.appendChild(notification);

      // Entferne Notification nach 5 Sekunden
      setTimeout(() => {
        notification.remove();
      }, 5000);
    }

    async function endGame() {
      const now = new Date();
      const hour = now.getHours();
      const isWeekend = [0, 6].includes(now.getDay());

      // Stelle sicher, dass categoryStats immer ein Objekt ist
      if (!currentStats.categoryStats) {
        currentStats.categoryStats = {};
      }

      // Initialisiere die Kategorie, falls sie noch nicht existiert
      if (!currentStats.categoryStats[categoryName || ""]) {
        currentStats.categoryStats[categoryName || ""] = {
          played: 0,
          wins: 0,
          highScore: 0,
          perfectGames: 0,
        };
      }

      const updatedStats: PlayerStats = {
        ...currentStats,
        userId: userId || "",
        totalGames: currentStats.totalGames + 1,
        totalCorrectAnswers: currentStats.totalCorrectAnswers + correctAnswers,
        totalPoints: currentStats.totalPoints + score,
        totalJokersUsed:
          currentStats.totalJokersUsed +
          (maxJokers - currentJokerState.jokerUsedCount),
        gamesWithoutJoker: currentJokerState.jokerUsed
          ? currentStats.gamesWithoutJoker
          : currentStats.gamesWithoutJoker + 1,
        perfectGames:
          correctAnswers === totalRounds
            ? currentStats.perfectGames + 1
            : currentStats.perfectGames,
        fastAnswers: currentStats.fastAnswers + fastAnswersThisGame,
        maxCorrectAnswersPerGame: Math.max(
          currentStats.maxCorrectAnswersPerGame,
          correctAnswers,
        ),
        fastAnswersTotal: currentStats.fastAnswersTotal + fastAnswersThisGame,
        earlyGames:
          hour < 9 ? currentStats.earlyGames + 1 : currentStats.earlyGames,
        eveningGames:
          hour >= 18
            ? currentStats.eveningGames + 1
            : currentStats.eveningGames,
        weekendGames: isWeekend
          ? currentStats.weekendGames + 1
          : currentStats.weekendGames,
        lastPlayedAt: now,
        lastUpdated: now,

        // Schwierigkeitsgrad-spezifische Updates
        easyDifficultyWins:
          difficulty === "easy" && correctAnswers === totalRounds
            ? currentStats.easyDifficultyWins + 1
            : currentStats.easyDifficultyWins,
        mediumDifficultyWins:
          difficulty === "medium" && correctAnswers === totalRounds
            ? currentStats.mediumDifficultyWins + 1
            : currentStats.mediumDifficultyWins,
        hardDifficultyWins:
          difficulty === "hard" && correctAnswers === totalRounds
            ? currentStats.hardDifficultyWins + 1
            : currentStats.hardDifficultyWins,

        // Kategorie-Updates mit Sicherheitsprüfungen
        categoryStats: {
          ...currentStats.categoryStats,
          [categoryName || ""]: {
            played:
              (currentStats.categoryStats[categoryName || ""]?.played || 0) + 1,
            wins:
              correctAnswers === totalRounds
                ? (currentStats.categoryStats[categoryName || ""]?.wins || 0) +
                  1
                : currentStats.categoryStats[categoryName || ""]?.wins || 0,
            highScore: Math.max(
              currentStats.categoryStats[categoryName || ""]?.highScore || 0,
              score,
            ),
            perfectGames:
              correctAnswers === totalRounds
                ? (currentStats.categoryStats[categoryName || ""]
                    ?.perfectGames || 0) + 1
                : currentStats.categoryStats[categoryName || ""]
                    ?.perfectGames || 0,
          },
        },

        // Stelle sicher, dass categoryWins immer ein Objekt ist
        categoryWins: {
          ...(currentStats.categoryWins || {}),
          [categoryName || ""]:
            correctAnswers === totalRounds
              ? ((currentStats.categoryWins || {})[categoryName || ""] || 0) + 1
              : (currentStats.categoryWins || {})[categoryName || ""] || 0,
        },
      };

      try {
        // Prüfe Achievements
        const unlockedAchievements = await achievementSystem.checkAchievements(
          userId as string,
          updatedStats,
        );

        if (unlockedAchievements.length > 0) {
          unlockedAchievements.forEach((achievement) => {
            showAchievementNotification(achievement);
          });
        }

        // Speichere aktualisierte Statistiken
        await updatePlayerStats(userId as string, updatedStats);

        // Aktualisiere lokale Stats
        currentStats = updatedStats;
        console.log("Player Stats Updated", currentStats);
      } catch (error) {
        console.error("Fehler beim Beenden des Spiels:", error);
      }

      // Reset Game-spezifische Tracker
      fastAnswersThisGame = 0;

      const config = {
        userId: userId || "",
        categoryName: categoryName || "",
        difficulty: difficulty || "easy",
        totalRounds,
        correctAnswers,
        score,
        totalUserPoints,
        currentCategoryPointsValue,
      };

      const ui = {
        showGoldenLpPopup: () => showGoldenLpPopup(score),
        showEndgamePopup: () => showEndgamePopup(score),
      };

      handleEndGame(config, ui, {
        onError: (error) => {
          ErrorHandler.handleSaveError(error, "score", {
            userId: config.userId,
            totalUserPoints: config.totalUserPoints + config.score,
            category: config.categoryName,
            categoryPoints: config.currentCategoryPointsValue + config.score,
          });
        },
      });
    }

    // Event-Listener für die Restart-Buttons
    document
      .getElementById("restart-button")
      ?.addEventListener("click", restartGame);
    document
      .getElementById("restart-button-lp")
      ?.addEventListener("click", restartGame);

    function getCurrentQuestion() {
      return currentQuestion;
    }

    const initialQuestion = getRandomQuestion(
      albums,
      difficulty || "easy",
      totalRounds,
    );

    if (initialQuestion) {
      loadQuestion(initialQuestion.randomQuestion, initialQuestion.randomAlbum);
    }

    await loadPlayerStats(userId as string);

    window.addEventListener("beforeunload", (e) => {
      if (QueueManager.hasUnsavedData()) {
        e.preventDefault();
      }
    });
  });
</script>
